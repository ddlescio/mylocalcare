{% extends "base.html" %}

{% block head_extra %}
  <meta name="chat-aperta" content="true">
  <script>
    document.addEventListener("DOMContentLoaded", () => {
      document.body.dataset.chat = "true";
    });
  </script>
{% endblock %}

{% block content %}
<style>
:root {
  --navbar-height: 70px;
}

/* ğŸŒ DESKTOP */
body {
  background: linear-gradient(to bottom right, #f9fafb, #eef2f7);
}

.max-w-3xl.mx-auto {
  border-radius: 1.25rem;
  overflow: hidden;
  background: rgba(255,255,255,0.7);
  backdrop-filter: blur(8px);
  border: 1px solid #e5e7eb;
  margin-top: 0 !important;
}

/* ğŸ’¬ Bolle messaggi */
.bubble {
  border-radius: 1rem;
  padding: 0.35rem 0.75rem;
  font-size: 0.9rem;
  line-height: 1.25rem;
  max-width: 75%;
  box-shadow: 0 1px 2px rgba(0,0,0,0.05);
  margin: 2px 0;
}
.bubble-me {
  background: #3b82f6;
  color: white;
  border-top-right-radius: 0.4rem;
}
.bubble-other {
  background: #fff;
  color: #1f2937;
  border: 1px solid #e5e7eb;
  border-top-left-radius: 0.4rem;
}

/* ğŸ§© Header Desktop */
.chat-header {
  position: sticky;
  top: 0;
  z-index: 30;
  background: rgba(255,255,255,0.9);
  backdrop-filter: blur(8px);
  border-bottom: 1px solid #e5e7eb;
  padding: 0.75rem 1rem;
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 0.4rem;
  box-shadow: 0 2px 5px rgba(0,0,0,0.05);
}
.chat-header img { width: 44px; height: 44px; }

/* --- ğŸ“± MOBILE --- */
@media (max-width: 480px) {

  :root {
    --vvh: 1vh; /* fallback, verrÃ  aggiornato da JS su iOS */
  }

  html, body {
    /* ğŸ”¥ invece di height:100% â†’ segue il viewport reale gestito da --vvh */
    height: calc(var(--vvh) * 100);
    margin: 0;

    /* tieni il blocco scroll pagina (come avevi) */
    overflow: hidden;

    background: #fff !important;

    /* ğŸ”¥ iOS: evita â€œrimbalziâ€/ricomposizioni strane */
    overscroll-behavior: none;
    -webkit-overflow-scrolling: auto;
  }

  /* container principale chat */
  #chatContainer {
    position: fixed;
    top: var(--navbar-height);
    left: 0;
    right: 0;

    /* ğŸ”¥ invece di bottom:0 -> height controllata (fix iOS keyboard) */
    height: calc((var(--vvh) * 100) - var(--navbar-height));

    display: flex;
    flex-direction: column;
    background: #fff;

    /* ğŸ”¥ iOS: stabilizza i fixed quando cambia viewport (tastiera) */
    transform: translateZ(0);
    will-change: height;
  }

  /* disattiva card desktop */
  .max-w-3xl.mx-auto {
    all: unset;
    display: flex;
    flex-direction: column;
    height: 100%;
    min-height: 0; /* importante per flex overflow */
  }

  /* header */
  .chat-header {
    flex: 0 0 auto;
    position: relative !important;
    box-shadow: 0 1px 3px rgba(0,0,0,0.05);
    z-index: 5;
  }

  /* area messaggi */
  #msgWrap {
    flex: 1 1 auto;
    min-height: 0;
    height: auto !important;          /* âœ… OVERRIDE di h-[65vh] (Tailwind) */
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    background: #f9fafb;
    padding: 0.5rem 0.7rem;
  }

  /* typing indicator */
  #typingIndicator {
    flex: 0 0 auto;
  }

  /* composer */
  #composer {
    flex: 0 0 auto;

    position: relative;               /* âœ… NO sticky su iOS */
    bottom: auto;

    border-top: 1px solid #e5e7eb;
    background: #fff;
    padding: 0.5rem 0.8rem;

    /* safe area iPhone (notch / home bar) */
    padding-bottom: calc(0.5rem + env(safe-area-inset-bottom));

    z-index: 6;
  }

  /* BLOCCA ZOOM IOS */
  .chat-input {
    font-size: 16px !important;
  }

  .send-btn {
    font-size: 14px;
  }

  body[data-chat="true"] footer {
    display: none !important;
  }

  .chat-header img {
    width: 36px !important;
    height: 36px !important;
    min-width: 36px;
    min-height: 36px;
    object-fit: cover;
    display: block;
  }
}
</style>

<style>
/* âœ… Mostra sempre su desktop */
@media (min-width: 641px) {
  body[data-chat="true"] nav .user-info {
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
  }
}

/* âœ… Nascondi solo su mobile */
@media (max-width: 640px) {
  body[data-chat="true"] nav .user-info {
    display: none !important;
    visibility: hidden !important;
    opacity: 0 !important;
  }
}
</style>
<style>
/* -------------------------------------------------------
   FIX: Evita che lâ€™header della chat copra il primo messaggio
   Desktop + iPad (min-width: 481px)
------------------------------------------------------- */
@media (min-width: 481px) {

  /* Lâ€™header deve stare sotto la navbar */
  .chat-header {
    position: sticky !important;
    top: var(--navbar-height) !important;
    z-index: 200 !important;
  }

  /* Aggiungo spazio sufficiente per far vedere il primo messaggio */
  #msgWrap {
    padding-top: 80px !important; /* valore testato per imitare mobile */
  }
}
</style>



<div id="chatContainer">
<div class="max-w-3xl mx-auto rounded-2xl shadow bg-white/70 backdrop-blur-md overflow-hidden mt-6 border border-gray-100">

  <!-- header -->
<div class="chat-header flex items-center justify-between px-4 py-3 border-b bg-white/80 backdrop-blur">
      <!-- Pulsante torna indietro -->
      <div class="flex items-center gap-2">

        <a id="backBtn" href="#"
           class="chat-back flex items-center gap-1 text-sm text-gray-500 hover:text-blue-600 transition">
          â† <span class="hidden sm:inline">Torna</span>
        </a>

        {% if g.utente['ruolo'] == 'admin' %}
        <form action="{{ url_for('chiudi_chat', other_id=altro['id']) }}"
              method="POST"
              onsubmit="return confirm('Vuoi davvero chiudere definitivamente la chat?');">
            <button class="px-3 py-1.5 bg-red-100 text-red-700 border border-red-300 rounded-lg text-xs hover:bg-red-200">
                âŒ Chiudi
            </button>
        </form>
        {% endif %}

      </div>

    <!-- Info utente -->
    {% if not is_support %}
      <!-- âœ… UTENTE NORMALE: cliccabile -->
      <a id="openProfile" href="{{ url_for('profilo_pubblico', id=altro['id']) }}"
         class="flex items-center gap-3 group hover:bg-gray-50 rounded-lg px-2 py-1 transition"
         title="Vai al profilo pubblico di @{{ altro['username'] }}">
    {% else %}
      <!-- ğŸ›Ÿ SUPPORTO: NON cliccabile (div al posto di <a>) -->
      <div class="flex items-center gap-3 px-2 py-1">
    {% endif %}

        <img src="{{ url_for('static', filename=altro['foto_profilo']) if altro['foto_profilo'] else url_for('static', filename='images/default_user.png') }}"
             alt="Profilo di {{ altro['username'] }}"
             class="w-9 h-9 rounded-full object-cover border border-gray-200 shadow-sm">

        <div class="flex flex-col leading-tight">
          <span class="font-medium text-gray-800">@{{ altro['username'] }}</span>
          <span class="text-xs text-gray-500">in chat con te</span>
        </div>

    {% if not is_support %}
      </a>
    {% else %}

      </div>
    {% endif %}
    <!-- ğŸ¥ Pulsante Video -->
    <button id="videoBtn"
            class="px-3 py-1.5 bg-green-100 text-green-700 border border-green-300 rounded-lg text-xs hover:bg-green-200">
        ğŸ¥ Video
    </button>


  </div>

  <!-- AREA MESSAGGI -->
  <div id="msgWrap"
       class="h-[65vh] overflow-y-auto px-6 py-5 bg-gradient-to-b from-gray-50 to-gray-100 space-y-1 rounded-b-2xl">
       {% set last_written_day = None %}
       {% for m in conversazione %}
         {% set is_me = (m['mittente_id'] == g.utente['id']) %}
         <div class="flex {% if is_me %}justify-end{% else %}justify-start{% endif %}">
           <div data-mid="{{ m['id'] }}" data-created-at="{{ m['created_at'] }}"
                class="bubble {% if is_me %}bubble-me{% else %}bubble-other{% endif %}">
             <div class="whitespace-pre-wrap break-words">{{ m['testo'] }}</div>
             <div class="flex items-center justify-end gap-1 mt-0.5 text-[10px] opacity-70 text-right">
               {% set dt = m['created_at'] | replace("T", " ") | to_datetime %}
               <span>
                 {% if dt %}{{ dt.astimezone(pytz.timezone("Europe/Rome")).strftime("%H:%M") }}{% endif %}
               </span>
               {% if is_me %}
                 {% if m['letto'] %}
                   <span class="text-blue-400">âœ…âœ…</span>
                 {% elif m['consegnato'] %}
                   <span class="text-gray-400">âœ…</span>
                 {% else %}
                   <span class="text-gray-400">â³</span>
                 {% endif %}
               {% endif %}
             </div>
           </div>
         </div>
       {% endfor %}
      </div>
  <!-- indicatore sta scrivendo -->
  <div id="typingIndicator" class="px-4 py-2 text-center typing-indicator hidden">
    Sta scrivendoâ€¦
  </div>

  <!-- composer -->
  <form id="composer" action="javascript:void(0)" class="flex items-center gap-2 p-3 border-t bg-white" autocomplete="off">
    <input type="hidden" id="destinatario_id" value="{{ altro['id'] }}">

    <!-- input + emoji -->
    <div class="relative flex-1">
      <input id="msgInput" type="text" name="testo"
             class="chat-input w-full pr-10"
             placeholder="Scrivi un messaggioâ€¦" required>

      <button type="button" id="emojiBtn"
              class="absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 emoji-btn text-lg"
              aria-label="Apri emoji">ğŸ˜Š</button>

      <!-- emoji popover -->
      <div id="emojiPopover"
           class="hidden absolute bottom-[110%] right-0 w-64 max-h-56 overflow-y-auto rounded-xl border bg-white shadow-lg p-2">
        <div class="grid grid-cols-8 gap-1 text-lg leading-none select-none">
          {% for e in ['ğŸ˜€','ğŸ˜','ğŸ˜‚','ğŸ¤£','ğŸ˜Š','ğŸ˜','ğŸ˜˜','ğŸ˜','ğŸ¤—','ğŸ¤”','ğŸ˜…','ğŸ™ƒ','ğŸ™‚','ğŸ˜‡','ğŸ¥³','ğŸ¤©',
                       'ğŸ‘','ğŸ‘','ğŸ™','ğŸ‘','ğŸ’ª','ğŸ”¥','âœ¨','ğŸ‰','â¤ï¸','ğŸ§¡','ğŸ’›','ğŸ’š','ğŸ’™','ğŸ’œ','ğŸ¤','ğŸ¤'] %}
            <button type="button" class="emoji-btn p-1 hover:bg-gray-100 rounded">{{ e }}</button>
          {% endfor %}
        </div>
      </div>
    </div>

    <!-- pulsante invia -->
    <button id="sendBtn" type="submit"
            class="send-btn rounded-xl bg-blue-600 text-white px-5 py-2 text-sm font-medium shadow-sm hover:shadow-md">
      Invia
    </button>
  </form>
</div>

<!-- ğŸ¥ VIDEO OVERLAY -->
<div id="videoOverlay"
     class="hidden fixed inset-0 bg-black/80 z-[9999] flex items-center justify-center">

    <div id="videoContainer"
         class="relative w-[95%] h-[90%] bg-black rounded-xl overflow-hidden">

        <button id="closeVideo"
                class="absolute top-3 right-3 z-50 bg-red-600 text-white px-3 py-1 rounded-lg text-sm">
            âœ– Chiudi
        </button>

    </div>
</div>
<script>
  window.chatAperta = true;
  window.addEventListener('beforeunload', () => { window.chatAperta = false; });
</script>
<script>
if (!window.socket) {
  window.socket = io({ transports: ['websocket', 'polling'] });
  console.log("ğŸŸ¢ Socket globale creato");
}
</script>

<script>
  document.addEventListener("DOMContentLoaded", function initChat() {

    const meId = parseInt("{{ g.utente['id'] }}", 10);
    const socket = window.socket;

    const wrap = document.getElementById('msgWrap');
    const input = document.getElementById('msgInput');
    const form = document.getElementById('composer');
    const typingIndicator = document.getElementById('typingIndicator');

    const destId = parseInt(document.getElementById('destinatario_id').value, 10);

    console.log("ğŸŸ¢ Chat collegata al socket globale", { meId, destId, connected: socket.connected });

    function initSocketEvents() {
      console.log("ğŸŸ¢ Socket pronto â†’ join stanza");
      socket.emit('join', { user_id: meId });

      // ğŸ“¡ Notifica apertura (UNA SOLA VOLTA)
      socket.emit('chat_aperta', { other_id: destId });
      socket.emit('mark_as_read', { other_id: destId });
    }

    if (socket.connected) initSocketEvents();
    else socket.once('connect', initSocketEvents);

    window.addEventListener('beforeunload', () => socket.emit('chat_chiusa', { other_id: destId }));

  // ğŸ­ Emoji
  const emojiBtn = document.getElementById('emojiBtn');
  const emojiPopover = document.getElementById('emojiPopover');
  function toggleEmoji(open) {
    const willOpen = typeof open === 'boolean' ? open : emojiPopover.classList.contains('hidden');
    emojiPopover.classList.toggle('hidden', !willOpen);
  }
  function insertAtCursor(el, text) {
    const start = el.selectionStart ?? el.value.length;
    const end = el.selectionEnd ?? el.value.length;
    el.value = el.value.slice(0, start) + text + el.value.slice(end);
    const pos = start + text.length;
    el.setSelectionRange(pos, pos); el.focus();
  }
  emojiBtn.addEventListener('click', e => { e.preventDefault(); toggleEmoji(true); });
  emojiPopover.addEventListener('click', e => {
    const btn = e.target.closest('.emoji-btn'); if (!btn) return;
    insertAtCursor(input, btn.textContent); toggleEmoji(false);
  });
  document.addEventListener('click', e => {
    if (!emojiPopover.contains(e.target) && e.target !== emojiBtn) toggleEmoji(false);
  });
  document.addEventListener('keydown', e => { if (e.key === 'Escape') toggleEmoji(false); });

  // ğŸ”§ Utility
  function escapeHTML(str) {
    return str.replace(/[&<>"']/g, tag => ({
      '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
    }[tag]));
  }
  function formatOra(datetimeStr) {
      if (!datetimeStr) return '';

      // Normalizza eventuale spazio â†’ ISO valido
      const clean = datetimeStr.replace(' ', 'T');

      // LASCIA decidere al browser il fuso corretto
      const d = new Date(clean);

      if (isNaN(d)) return datetimeStr.slice(11, 16);

      const hh = String(d.getHours()).padStart(2, '0');
      const mm = String(d.getMinutes()).padStart(2, '0');

      return `${hh}:${mm}`;
  }

  // ğŸ§± Genera bolla messaggio
  function bubble({ id, mittente_id, testo, created_at, consegnato, letto, me_id }) {
    const isMe = mittente_id === me_id;
    const outer = document.createElement('div');
    outer.className = 'msg-line flex ' + (isMe ? 'justify-end' : 'justify-start');
    const inner = document.createElement('div');
    inner.className = 'bubble ' + (isMe ? 'bubble-me' : 'bubble-other');
    inner.setAttribute('data-mid', id);
    inner.setAttribute('data-created-at', created_at);
    const spunte = isMe
      ? `<span class="spunte">${
          letto
            ? '<span class="text-blue-400">âœ…âœ…</span>'
            : consegnato
              ? '<span class="text-gray-400">âœ…</span>'
              : '<span class="text-gray-400">â³</span>'
        }</span>` : '';
    inner.innerHTML = `
      <div class="whitespace-pre-wrap break-words">${escapeHTML(testo)}</div>
      <div class="flex items-center justify-end gap-1 mt-0.5 text-[10px] opacity-70 text-right">
        <span>${formatOra(created_at)}</span>${spunte}
      </div>`;
    outer.appendChild(inner);
    return outer;
  }

  // ğŸ§­ Scroll
  function isAtBottom() {
    const threshold = 60;
    return wrap.scrollHeight - wrap.scrollTop - wrap.clientHeight < threshold;
  }
  function scrollBottom(smooth = false) {
    requestAnimationFrame(() => {
      wrap.scrollTo({ top: wrap.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
    });
  }

  // âœï¸ Indicatore "sta scrivendo"
  let typingTimeout = null;
  let wasTyping = false;

  input.addEventListener("input", () => {
    // invia typing:true solo la prima volta
    if (!wasTyping) {
      wasTyping = true;
      socket.emit("typing", { to: destId, typing: true });
    }

    // reset timeout
    clearTimeout(typingTimeout);

    typingTimeout = setTimeout(() => {
      wasTyping = false;
      socket.emit("typing", { to: destId, typing: false });
    }, 2000); // puoi abbassare a 1000ms se vuoi piÃ¹ reattivitÃ 
  });

  socket.on('user_typing', data => {
    if (data.from !== destId) return;
    if (data.typing) {
      typingIndicator.classList.remove('hidden');
      clearTimeout(typingIndicator._hide);
      typingIndicator._hide = setTimeout(() => typingIndicator.classList.add('hidden'), 2000);
    } else typingIndicator.classList.add('hidden');
  });

  // ğŸ—“ï¸ Gestione intestazioni data (solo sopra il primo messaggio di ogni giorno)
  function formatDateIT(datetimeStr) {
    if (!datetimeStr) return '';
    try {
      const clean = datetimeStr.trim().replace('T', ' ').replace('Z', '').replace(/\//g, '-');
      const [y, m, d] = clean.split(' ')[0].split('-').map(Number);
      const dt = new Date(y, m - 1, d);
      const oggi = new Date();
      if (
        dt.getDate() === oggi.getDate() &&
        dt.getMonth() === oggi.getMonth() &&
        dt.getFullYear() === oggi.getFullYear()
      ) return 'Oggi';
      return dt.toLocaleDateString('it-IT', { day: '2-digit', month: 'long', year: 'numeric' });
    } catch { return ''; }
  }

  function ensureDateHeaderFor(datetimeStr) {
    if (!datetimeStr) return;
    const day = datetimeStr.split(/[ T]/)[0];

    // evita duplicati
    if (document.querySelector(`#msgWrap .date-header[data-day="${day}"]`)) return;

    // trova il primo messaggio del giorno
    const msgs = [...document.querySelectorAll('#msgWrap [data-created-at]')];
    const firstOfDay = msgs.find(msg => (msg.getAttribute('data-created-at') || '').startsWith(day));

    // crea intestazione
    const div = document.createElement('div');
    div.className = 'text-center text-xs text-gray-400 my-2 date-header';
    div.setAttribute('data-day', day);
    div.textContent = formatDateIT(datetimeStr);

    // inserisci sopra il primo messaggio del giorno
    if (firstOfDay && firstOfDay.parentNode) {
      firstOfDay.parentNode.parentNode.insertBefore(div, firstOfDay.parentNode);
    } else {
      document.getElementById('msgWrap').appendChild(div);
    }
  }

  function cleanDuplicateDates() {
    const seen = new Set();
    document.querySelectorAll('#msgWrap .date-header').forEach(el => {
      const day = el.getAttribute('data-day');
      if (seen.has(day)) el.remove(); else seen.add(day);
    });
  }

  function aggiornaIntestazioniDate() {
    const msgs = document.querySelectorAll('#msgWrap [data-created-at]');
    let lastDay = null;
    msgs.forEach(msg => {
      const raw = msg.getAttribute('data-created-at');
      if (!raw) return;
      const day = raw.split(/[ T]/)[0];
      if (day !== lastDay) {
        ensureDateHeaderFor(raw);
        lastDay = day;
      }
    });
    cleanDuplicateDates();
  }
  // ğŸ§¹ Allâ€™avvio
  aggiornaIntestazioniDate();
  setTimeout(() => scrollBottom(false), 100);

  // ğŸ’¬ Ricezione messaggi (versione blindata)
  socket.on('new_message', (m) => {

    try {

      const sameChat =
        (m.mittente_id === meId && m.destinatario_id === destId) ||
        (m.destinatario_id === meId && m.mittente_id === destId);

      if (!sameChat) return;

      const alreadyBottom = isAtBottom();

      if (m.created_at) {
        ensureDateHeaderFor(m.created_at);
      }

      const bolla = bubble({ ...m, me_id: meId });
      wrap.appendChild(bolla);

      cleanDuplicateDates();

      if (alreadyBottom) {
        setTimeout(() => scrollBottom(true), 80);
      }

      // â­ aggiorna spunte solo se Ã¨ mio
      if (m.mittente_id === meId) {
        const spunte = bolla.querySelector('.spunte');
        if (spunte) {
          if (m.letto) {
            spunte.innerHTML = '<span class="text-blue-400">âœ…âœ…</span>';
          } else if (m.consegnato) {
            spunte.innerHTML = '<span class="text-gray-400">âœ”</span>';
          } else {
            spunte.innerHTML = '<span class="text-gray-400">â³</span>';
          }
        }
      }

      // Se ricevo â†’ segno come letto
      if (m.destinatario_id === meId) {
        socket.emit('mark_as_read', { other_id: m.mittente_id });
      }

    } catch (err) {

      console.error("ğŸ”¥ Errore in new_message:", err, m);

    }

  });

  // ğŸ”µ Aggiornamento spunte
  socket.on('messages_read', data => {
    if (data.from !== destId) return;

    // aggiorna SOLO i messaggi inviati da me e NON aggiornati
    document.querySelectorAll('.bubble-me .spunte').forEach(spunte => {
      spunte.innerHTML = '<span class="text-blue-400">âœ…âœ…</span>';
    });
  });


  // ğŸ“¨ Invio messaggio
  form.addEventListener('submit', (e) => {
    e.preventDefault();
    const testo = input.value.trim();
    if (!testo) return;
    socket.emit('send_message', { destinatario_id: destId, testo });
    input.value = '';
    toggleEmoji(false);
  });
});
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {
  const back = document.getElementById("backBtn");
  if (!back) return;

  back.addEventListener("click", (e) => {
    e.preventDefault();

    // 1ï¸âƒ£ Segnala la chiusura della chat
    try {
      const destId = parseInt(document.getElementById("destinatario_id")?.value || "0", 10);
      if (window.socket && destId) window.socket.emit("chat_chiusa", { other_id: destId });
    } catch (_) {}

    // 2ï¸âƒ£ Torna alla pagina precedente se esiste
    if (document.referrer && document.referrer !== window.location.href) {
      window.history.back();
      return;
    }

    // 3ï¸âƒ£ Fallback: torna alla lista chat
    window.location.href = "{{ url_for('chat_threads_view') }}";
  });
});
</script>
  <script>
document.addEventListener("DOMContentLoaded", () => {
  const link = document.getElementById("openProfile");
  const destIdEl = document.getElementById("destinatario_id");
  if (!link || !destIdEl) return;

  link.addEventListener("click", () => {
    const destId = parseInt(destIdEl.value || "0", 10);
    try {
      if (window.socket && destId) window.socket.emit("chat_chiusa", { other_id: destId });
    } catch(_) {}
  });
});
</script>
<script src="https://unpkg.com/@daily-co/daily-js"></script>

<script>
document.addEventListener("DOMContentLoaded", async function () {

    // ==============================
    // SOCKET
    // ==============================
    const socket = window.socket;

    // ğŸ”¥ DEFINIZIONE CORRETTA
    const meId = parseInt("{{ g.utente['id'] }}");

    // ==============================
    // ELEMENTI
    // ==============================
    const videoBtn = document.getElementById("videoBtn");
    const overlay = document.getElementById("videoOverlay");
    const container = document.getElementById("videoContainer");
    const closeBtn = document.getElementById("closeVideo");
    const destId = parseInt(document.getElementById("destinatario_id").value);

    const incomingModal = document.getElementById("incomingCallModal");
    const acceptBtn = document.getElementById("acceptCall");
    const rejectBtn = document.getElementById("rejectCall");
    const callerNameEl = document.getElementById("callerName");

    let currentRoomName = null;
    let callObject = null;
    let incomingData = null;
    let pingInterval = null;

    // ğŸ”´ Se l'altro rifiuta la chiamata
    socket.on("video_call_rejected", (data) => {

        console.log("âŒ Chiamata rifiutata:", data);

        if (!currentRoomName) return;

        if (data.room === currentRoomName) {
            alert("L'utente ha rifiutato la chiamata.");
            endCall();
        }
    });
    // ğŸ”´ Se l'altro chiude la chiamata
    socket.on("video_call_left", (data) => {

        console.log("ğŸ‘‹ L'altro ha chiuso:", data);

        if (!currentRoomName) return;

        if (data.room === currentRoomName) {
            endCall();
        }
    });

    if (!videoBtn) return;

    // =======================================
    // ğŸ”¥ AVVIO AUTOMATICO SE CHIAMATA PENDENTE
    // =======================================
    const pendingRoomUrl  = sessionStorage.getItem("incomingCall_roomUrl");
    const pendingRoomName = sessionStorage.getItem("incomingCall_roomName");

    if (pendingRoomUrl && pendingRoomName) {

        console.log("ğŸ“ Avvio automatico chiamata entrante");

        sessionStorage.removeItem("incomingCall_roomUrl");
        sessionStorage.removeItem("incomingCall_roomName");

        startCall(pendingRoomName, pendingRoomUrl);
    }


    // ==============================
    // ğŸ¥ AVVIO VIDEO (CHIAMANTE)
    // ==============================
    videoBtn.addEventListener("click", async () => {

        if (!confirm("Vuoi avviare la videochiamata?")) return;

        videoBtn.disabled = true;
        videoBtn.innerText = "â³ Avvio...";

        try {

            const res = await fetch("/video/start", {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ altro_utente_id: destId })
            });

            const data = await res.json();

            if (!res.ok) {
                alert(data.error || "Errore video");
                resetBtn();
                return;
            }

            await startCall(data.room_name, data.room_url);

        } catch (_) {
            alert("Errore connessione video");
        }

        resetBtn();
    });

    function resetBtn() {
        videoBtn.disabled = false;
        videoBtn.innerText = "ğŸ¥ Video";
    }

    // ==============================
    // ğŸ¬ START CALL (COMUNE)
    // ==============================
    async function startCall(roomName, roomUrl) {

        currentRoomName = roomName;

        // â¤ï¸ avvia ping automatico
        if (pingInterval) clearInterval(pingInterval);

        pingInterval = setInterval(() => {
            if (!currentRoomName) return;

            fetch("/video/ping", {
                method: "POST",
                headers: {"Content-Type": "application/json"},
                body: JSON.stringify({room_name: currentRoomName})
            }).catch(() => {});
        }, 10000); // ogni 10 secondi

        overlay.classList.remove("hidden");

        container.innerHTML = `
            <div class="flex flex-col items-center justify-center h-full text-white">
                <h2 class="text-xl mb-6">Videochiamata pronta</h2>
                <div class="flex gap-4">
                    <button id="enterCall"
                            class="bg-green-600 px-5 py-2 rounded-lg">
                        Entra
                    </button>
                    <button id="cancelCall"
                            class="bg-gray-600 px-5 py-2 rounded-lg">
                        Annulla
                    </button>
                </div>
            </div>
        `;

        document.getElementById("cancelCall").onclick = () => {
            socket.emit("video_call_rejected", { room: currentRoomName });
            overlay.classList.add("hidden");
            currentRoomName = null;
        };

        document.getElementById("enterCall").onclick = async () => {

            container.innerHTML = "";

            callObject = Daily.createFrame(container, {
                showLeaveButton: true,
                iframeStyle: {
                    width: "100%",
                    height: "100%",
                    border: "0"
                }
            });

            callObject.on("left-meeting", () => {
                socket.emit("video_call_left", { room: currentRoomName });
                endCall();
            });

            callObject.on("error", () => {
                socket.emit("video_call_left", { room: currentRoomName });
                endCall();
            });

            await callObject.join({ url: roomUrl });
        };
    }

    // ==============================
    // âŒ CHIUDI CALL
    // ==============================
    closeBtn.addEventListener("click", async () => {
        if (callObject) await callObject.leave();
        endCall();
    });

    async function endCall() {

        overlay.classList.add("hidden");

        if (pingInterval) {
            clearInterval(pingInterval);
            pingInterval = null;
        }

        if (callObject) {
            callObject.destroy();
            callObject = null;
        }

        if (currentRoomName) {
            try {
                await fetch("/video/end", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ room_name: currentRoomName })
                });
            } catch (_) {}
        }

        currentRoomName = null;
    }

});
</script>
<script>
document.addEventListener("DOMContentLoaded", () => {

    const videoBtn = document.getElementById("videoBtn");
    if (!videoBtn) return;

    const socket = window.socket;
    const destId = parseInt(document.getElementById("destinatario_id").value);

    // =========================
    // ğŸ” CHECK STATUS ALLâ€™APERTURA
    // =========================
    socket.emit("check_video_status", { user_id: destId });

    socket.on("video_status_result", (data) => {
        if (data.busy) {
            videoBtn.disabled = true;
            videoBtn.innerText = "ğŸ”´ In chiamata";
            videoBtn.classList.remove("bg-green-100","text-green-700");
            videoBtn.classList.add("bg-gray-200","text-gray-500");
        }
    });

    // =========================
    // ğŸ”´ REALTIME BUSY UPDATE
    // =========================
    socket.on("video_busy", (data) => {

        if (!data) return;

        if (data.user_id === destId) {

            if (data.busy) {
                videoBtn.disabled = true;
                videoBtn.innerText = "ğŸ”´ In chiamata";
                videoBtn.classList.remove("bg-green-100","text-green-700");
                videoBtn.classList.add("bg-gray-200","text-gray-500");
            } else {
                videoBtn.disabled = false;
                videoBtn.innerText = "ğŸ¥ Video";
                videoBtn.classList.add("bg-green-100","text-green-700");
                videoBtn.classList.remove("bg-gray-200","text-gray-500");
            }

        }
    });

});
</script>
<script>
(function () {
  let lastH = null;

  function apply(h) {
    if (!h || h === lastH) return;
    lastH = h;
    document.documentElement.style.setProperty("--vvh", (h * 0.01) + "px");
  }

  function readHeight() {
    const vv = window.visualViewport;
    return vv ? vv.height : window.innerHeight;
  }

  function setVVH() {
    apply(readHeight());
  }

  // iOS: spesso serve un â€œdoppio tickâ€ per avere il valore finale
  function setVVHStable() {
    requestAnimationFrame(() => {
      setVVH();
      setTimeout(setVVH, 50);
      setTimeout(setVVH, 150);
    });
  }

  // init
  setVVHStable();

  const vv = window.visualViewport;
  if (vv) {
    vv.addEventListener("resize", setVVHStable, { passive: true });
    vv.addEventListener("scroll", setVVHStable, { passive: true });
  }

  window.addEventListener("resize", setVVHStable, { passive: true });
  window.addEventListener("orientationchange", () => setTimeout(setVVHStable, 50), { passive: true });

  // ğŸ”¥ questi due risolvono molti â€œlayout resta sfasato dopo chiusura tastieraâ€
  document.addEventListener("focusin", setVVHStable, { passive: true });
  document.addEventListener("focusout", () => setTimeout(setVVHStable, 50), { passive: true });

})();
</script>
</div>
{% endblock %}
